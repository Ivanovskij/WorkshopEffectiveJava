package com.ivo.chapter1.creatingAndDestroyingObjects;

// Can you spot the "memory leak"?
class Stack {

    private Object[] elements;
    private int size = 0;

    public Stack(int initialCapacity) {
        this.elements = new Object[initialCapacity];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    /*public Object pop() {
        if (size == 0) {
            throw new NullPointerException();
        }
        return elements[--size];
    }*/

        /*
    
                Где же происходит утечка? Если стек растет, а затем уменьшается, то объекты, которые были
            вытолкнуты из стека, не могут быть удалены, даже если программа, пользующаяся этим стеком, уже не
            имеет ссылок на них. Все дело в том, что стек сохраняет устаревшие ссылки (obsolete reference) на
            объекты. Устаревшая ссылка это такая ссылка, которая уже никогда не будет разыменована. В данном
            случае устаревшими являются любые ссылки, оказавшиеся за пределами активной части массива
            элементов. Активная же часть стека включает в себя элементы, чей индекс меньше значения
            переменной size.
                Утечка памяти в языках с автоматической сборкой мусора (или точнее, непреднамеренное
            сохранение объектов - unintentional object retention) весьма коварна. Если ссылка на объект была
            непреднамеренно сохранена, сборщик мусора не сможет удалить не только этот объект, но и все
            объекты, на которые он ссылается, и т. д. Если даже непреднамеренно было сохранено всего
            несколько объектов, многие и многие объекты могут стать недоступными сборщику мусора, а это может
            оказать большое влияние на производительность программы.
            Проблемы такого типа решаются очень просто: как только ссылки устаревают, их нужно обнулять.
            В случае с нашим классом Stack ссылка становится устаревшей, как только ее объект выталкивается
            из стека. Исправленный вариант метода рор выглядит следующим образом:
     */    
    
    /*
            Так когда же следует обнулять ссылку? Какая особенность класса Stack сделала его
            восприимчивым к утечке памяти? Класс Stack управляет своей памятью. Пул хранения состоит из
            массива элементов (причем его ячейками являются ссылки на объекты, а не сами объекты). Как
            указывалось выше, элементы в активной части массива считаются занятыми, в остальной -
            свободными. Сборщик мусора этого знать никак не может, и для него все ссылки на объекты,
            хранящиеся в массиве, в равной' степени действительны. Только программисту известно, что
            неактивная часть массива не нужна. Сообщить об этом сборщику мусора программист может, лишь
            вручную обнуляя элементы массива по мере того, как они переходят в не активную часть массива.
            Вообще говоря, если какой-либо класс начинает управлять своей памятью, программист должен
            подумать об утечке памяти. Как только элемент массива освобождается, любые ссылки на объекты,
            имевшиеся в этом элементе, необходимо обнулять.
    
    */
    public Object pop() {
        if (size == 0) {
            throw new NullPointerException();
        }
        Object result = elements[--size];
        elements[size] = null;  // Убираем устаревшую ссылку
        return result;
    }

    /**
     * Ensure space for at least one more element, roughly doubling the capacity
     * each time the array needs to grow.
     */
    private void ensureCapacity() {
        if (elements.length == size) {
            Object[] oldElements = elements;
            elements = new Object[2 * elements.length + 1];
            System.arraycopy(oldElements, 0, elements, 0, size);

        }
    }
}

class EliminateObsoleteObjectReferencesApp {

    public static void main(String[] args) {
        Stack s = new Stack(0);
        for (int i = 0; i < 10000; i++) {
            s.push(Math.random());
        }
        for (int i = 0; i < 10000; i++) {
            System.out.println(s.pop());
        }
    }
}
